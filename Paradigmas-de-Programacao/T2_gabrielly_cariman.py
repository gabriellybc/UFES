# -*- coding: utf-8 -*-
"""T2_gabrielly_cariman.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1i7soZlPPyM2Px5WY5N4g-Q-5QjVbMecy
"""

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# %pip install sparqlwrapper

"""
Executa uma consulta SPARQL no endpoint DBpedia para obter informações sobre cidades.
"""
from SPARQLWrapper import SPARQLWrapper, JSON
from functools import reduce

# Set endpoint
sparql = SPARQLWrapper("http://dbpedia.org/sparql")

# Set query
sparql.setQuery("""
            PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
            PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
            PREFIX dbo: <http://dbpedia.org/ontology/>
            PREFIX geo: <http://www.w3.org/2003/01/geo/wgs84_pos#>

            SELECT DISTINCT ?city ?name ?country ?population ?area ?latitude ?longitude
            WHERE {
                ?city a dbo:City;
                    rdfs:label ?name;
                    dbo:country ?country;
                    dbo:populationTotal ?population;
                    dbo:areaTotal ?area;
                    geo:lat ?latitude;
                    geo:long ?longitude.
                FILTER (lang(?name) = 'en')
            }
""")

# Set return format to JSON
sparql.setReturnFormat(JSON)

# Execute query and return result in JSON format
results = sparql.query().convert()

def city_data(res_dict):
    """
    Converte os resultados de uma consulta SPARQL em uma lista de dicionários.

    Args:
        res_dict (dict): Dicionário contendo os resultados da consulta SPARQL.

    Returns:
        list: Lista de dicionários, cada um representando uma cidade com seus dados.
    """
    VALUES = res_dict['results']['bindings']
    return list(map(lambda item: dict(
        map(lambda key: (key, item[key]['value']),
            item.keys())
    ), VALUES))


def city_data_closed(lista, name:str=None, country:str=None, population:str=None, area:str=None, latitude:str=None, longitude:str=None):
    """
    Filtra uma lista de cidades com base em critérios específicos.

    Args:
        lista (list): Lista de dicionários representando cidades.
        name (str, optional): Nome da cidade a ser filtrado.
        country (str, optional): País da cidade a ser filtrado.
        population (str, optional): População da cidade a ser filtrada.
        area (str, optional): Área da cidade a ser filtrada.
        latitude (str, optional): Latitude da cidade a ser filtrada.
        longitude (str, optional): Longitude da cidade a ser filtrada.

    Returns:
        list or bool: Lista filtrada de cidades ou False se nenhum resultado for encontrado e todos os critérios forem fornecidos.
    """
    if name and country and population and area and latitude and longitude:
        cities = list(filter(lambda x: x['name'] == name and x['country'] == country and x['population'] == population and x['area'] == area and x['latitude'] == latitude and x['longitude'] == longitude, lista))
        return False if len(cities) == 0 else True
    else:
        return lista


def city_with_max_population(lista, population:str=None, name:str=None):
    """
    Encontra a cidade com a maior população em uma lista e realiza uma comparação com base nos critérios fornecidos.

    Args:
        lista (list): Lista de dicionários representando cidades.
        population (str, optional): População esperada da cidade com a maior população.
        name (str, optional): Nome esperado da cidade com a maior população.

    Returns:
        bool or tuple: True se as condições forem atendidas, False se não forem, ou uma tupla contendo o nome e a população da cidade com a maior população.
    """
    city = max(lista, key=lambda x: int(x['population']))
    if name and population:
        return city['name'] == name and city['population'] == population
    elif name:
        return city['name'] if city['name'] == name else False
    elif population:
        return city['population'] if city['population'] == population else False
    else:
        return city['name'], city['population']


def city_with_min_population(lista, population:str=None, name:str=None):
    """
    Encontra a cidade com a menor população em uma lista e realiza uma comparação com base nos critérios fornecidos.

    Args:
        lista (list): Lista de dicionários representando cidades.
        population (str, optional): População esperada da cidade com a menor população.
        name (str, optional): Nome esperado da cidade com a menor população.

    Returns:
        bool or tuple: True se as condições forem atendidas, False se não forem, ou uma tupla contendo o nome e a população da cidade com a menor população.
    """
    city = min(lista, key=lambda x: int(x['population']))
    if name and population:
        return city['name'] == name and city['population'] == population
    elif name:
        return city['name'] if city['name'] == name else False
    elif population:
        return city['population'] if city['population'] == population else False
    else:
        return city['name'], city['population']


def city_with_max_area(lista, area:str=None, name:str=None):
    """
    Encontra a cidade com a maior área em uma lista e realiza uma comparação com base nos critérios fornecidos.

    Args:
        lista (list): Lista de dicionários representando cidades.
        area (str, optional): Área esperada da cidade com a maior área.
        name (str, optional): Nome esperado da cidade com a maior área.

    Returns:
        bool or tuple: True se as condições forem atendidas, False se não forem, ou uma tupla contendo o nome e a área da cidade com a maior área.
    """
    city = max(lista, key=lambda x: float(x['area']))
    if name and area:
        return city['name'] == name and city['area'] == area
    elif name:
        return city['name'] if city['name'] == name else False
    elif area:
        return city['area'] if city['area'] == area else False
    else:
        return city['name'], city['area']


def city_with_min_area(lista, area:str=None, name:str=None):
    """
    Encontra a cidade com a menor área em uma lista e realiza uma comparação com base nos critérios fornecidos.

    Args:
        lista (list): Lista de dicionários representando cidades.
        area (str, optional): Área esperada da cidade com a menor área.
        name (str, optional): Nome esperado da cidade com a menor área.

    Returns:
        bool or tuple: True se as condições forem atendidas, False se não forem, ou uma tupla contendo o nome e a área da cidade com a menor área.
    """
    city = min(lista, key=lambda x: float(x['area']))
    if name and area:
        return city['name'] == name and city['area'] == area
    elif name:
        return city['name'] if city['name'] == name else False
    elif area:
        return city['area'] if city['area'] == area else False
    else:
        return city['name'], city['area']


def city_coordinates(lista, name:str=None, latitude:str=None, longitude:str=None):
    """
    Filtra cidades com base nas coordenadas geográficas fornecidas.

    Args:
        lista (list): Lista de dicionários representando cidades.
        name (str, optional): Nome da cidade a ser filtrado.
        latitude (str, optional): Latitude da cidade a ser filtrada.
        longitude (str, optional): Longitude da cidade a ser filtrada.

    Returns:
        list or bool: Lista de coordenadas filtradas ou False se nenhum resultado for encontrado e todos os critérios forem fornecidos.
    """
    if name and latitude and longitude:
        cities_name_latitude_longitude = list(filter(lambda x: x['name'] == name and x['latitude'] == latitude and x['longitude'] == longitude, lista))
        return False if len(cities_name_latitude_longitude) == 0 else True
    elif name and latitude:
        cities_name_latitude = list(filter(lambda x: x['name'] == name and x['latitude'] == latitude, lista))
        return False if len(cities_name_latitude) == 0 else list(map(lambda d: {'longitude': d['longitude']}, cities_name_latitude))
    elif name and longitude:
        cities_name_longitude = list(filter(lambda x: x['name'] == name and x['longitude'] == longitude, lista))
        return False if len(cities_name_longitude) == 0 else list(map(lambda d: {'latitude': d['latitude']}, cities_name_longitude))
    elif latitude and longitude:
        cities_latitude_longitude = list(filter(lambda x: x['latitude'] == latitude and x['longitude'] == longitude, lista))
        return False if len(cities_latitude_longitude) == 0 else list(map(lambda d: {'name': d['name']}, cities_latitude_longitude))
    elif name:
        cities_name = list(filter(lambda x: x['name'] == name, lista))
        return False if len(cities_name) == 0 else list(map(lambda d: {'latitude': d['latitude'], 'longitude': d['longitude']}, cities_name))
    elif latitude:
        cities_latitude = list(filter(lambda x: x['latitude'] == latitude, lista))
        return False if len(cities_latitude) == 0 else list(map(lambda d: {'name': d['name'], 'longitude': d['longitude']}, cities_latitude))
    elif longitude:
        cities_longitude = list(filter(lambda x: x['longitude'] == longitude, lista))
        return False if len(cities_longitude) == 0 else list(map(lambda d: {'name': d['name'], 'latitude': d['latitude']}, cities_longitude))
    else:
        return list(map(lambda d: {'name': d['name'], 'latitude': d['latitude'], 'longitude': d['longitude']}, lista))


def cities_population_above_one_million(lista, count:int=None):
    """
    Conta o número de cidades com população acima de um milhão.

    Args:
        lista (list): Lista de dicionários representando cidades.
        count (int, optional): Número esperado de cidades com população acima de um milhão.

    Returns:
        bool or int: True se o número de cidades corresponder ao esperado, False se não corresponder, ou o total de cidades com população acima de um milhão.
    """
    cities_count = len(list(filter(lambda x: int(x['population']) > 1000000, lista)))
    return False if count and cities_count != count else (cities_count if count is None else True)


def city_density(lista, density:float=None, name:str=None):
    """
    Calcula e filtra cidades com base na densidade populacional.

    Args:
        lista (list): Lista de dicionários representando cidades.
        density (float, optional): Densidade populacional esperada.
        name (str, optional): Nome da cidade para a qual a densidade deve ser calculada.

    Returns:
        bool or list: True se as condições forem atendidas, False se não forem, ou uma lista de cidades com a densidade calculada.
    """
    if density and name:
        cities_density_name = list(filter(lambda x: x['name'] == name and (float(x['population']) / float(x['area'])) == density, lista))
        return False if len(cities_density_name) == 0 else True
    elif density:
        cities_density = list(filter(lambda x: (float(x['population']) / float(x['area'])) == density, lista))
        return False if len(cities_density) == 0 else list(map(lambda d: {'name': d['name']}, cities_density))
    elif name:
        cities_name = list(filter(lambda x: x['name'] == name, lista))
        return False if len(cities_name) == 0 else list(map(lambda d: {'density': (float(d['population']) / float(d['area']))}, cities_name))
    else:
        return list(map(lambda d: {'name': d['name'], 'density': (float(d['population']) / float(d['area']))}, lista))


def countries_with_cities(lista, countries:list=None):
    """
    Identifica os países que têm cidades na lista.

    Args:
        lista (list): Lista de dicionários representando cidades.
        countries (list, optional): Lista de países esperados.

    Returns:
        bool or set: True se os países corresponderem aos esperados, False se não corresponderem, ou um conjunto de países presentes na lista.
    """
    countrie_list = set(list(map(lambda x: x['country'], lista)))
    return False if countries and set(countries) != countrie_list else (countrie_list if countries is None else True)


def substring(lista, substr):
    """
    Filtra cidades cujo nome contém a substring fornecida.

    Args:
        lista (list): Lista de dicionários representando cidades.
        substr (str): Substring para filtrar os nomes das cidades.

    Returns:
        list: Lista de cidades cujos nomes contêm a substring fornecida.
    """
    return list(filter(lambda x: x['name'].__contains__(substr), lista))


def cities_with_substring(lista, substr:str=None, name:str=None):
    """
    Filtra cidades com base em uma substring no nome e no nome fornecido.

    Args:
        lista (list): Lista de dicionários representando cidades.
        substr (str, optional): Substring para filtrar os nomes das cidades.
        name (str, optional): Nome da cidade a ser filtrado.

    Returns:
        bool or list: True se as condições forem atendidas, False se não forem, ou uma lista de nomes das cidades filtradas.
    """
    if substr and name:
        cities = substring(lista, substr)
        cities_name = list(filter(lambda x: x['name'] == name, cities))
        return False if len(cities_name) == 0 else True
    elif substr:
        cities_substr = substring(lista, substr)
        return False if len(cities_substr) == 0 else list(map(lambda x: x['name'], cities_substr))
    elif name:
        cities_name = list(filter(lambda x: x['name'] == name, lista))
        return False if len(cities_name) == 0 else list(map(lambda x: x['name'], cities_name))
    else:
        return list(map(lambda x: x['name'], lista))


def cities_ordered_by_population_descending(lista, names:list=None):
    """
    Ordena as cidades por população em ordem decrescente e compara com uma lista de nomes.

    Args:
        lista (list): Lista de dicionários representando cidades.
        names (list, optional): Lista de nomes esperados de cidades.

    Returns:
        bool or set: True se os nomes corresponderem aos esperados, False se não corresponderem, ou um conjunto de nomes das cidades ordenadas.
    """
    sorted_list = sorted(lista, key=lambda x: int(x['population']), reverse=True)
    names_list = set(list(map(lambda x: x['name'], sorted_list)))
    return False if names and set(names) != names_list else (names_list if names is None else True)


def total_cities_count(lista, total:int=None):
    """
    Conta o total de cidades na lista e compara com o total esperado.

    Args:
        lista (list): Lista de dicionários representando cidades.
        total (int, optional): Total esperado de cidades.

    Returns:
        bool or int: True se o total corresponder ao esperado, False se não corresponder, ou o total de cidades na lista.
    """
    total_cities = len(lista)
    return False if total and total_cities != total else (total_cities if total is None else True)


def city_exists(lista, name:str=None):
    """
    Verifica se uma cidade com o nome fornecido existe na lista.

    Args:
        lista (list): Lista de dicionários representando cidades.
        name (str, optional): Nome da cidade a ser verificado.

    Returns:
        bool or list: True se a cidade existir, False se não existir, ou uma lista de nomes de cidades.
    """
    if name:
        cities_name = list(filter(lambda x: x['name'] == name, lista))
        return False if len(cities_name) == 0 else True
    else:
        return list(map(lambda x: x['name'], lista))

"""
O recurso reduce é usado para aplicar uma função de forma cumulativa aos itens de uma sequência,
reduzindo a sequência a um único valor. Na maioria das funções apresentadas no código,
a aplicação de reduce não é necessária porque essas funções utilizam operações de filtragem,
mapeamento ou ordenação que não se beneficiam da abordagem cumulativa de reduce.

Aqui está uma nova função que utiliza reduce para calcular a soma total da população das cidades na lista:
"""
def total_population(lista, total:int=None):
    """
    Calcula a soma total da população das cidades na lista.

    Args:
        lista (list): Lista de dicionários representando cidades.
        total (int, optional): Total esperado da população das cidades.

    Returns:
        bool or int: True se a soma corresponder ao esperado, False se não corresponder, ou a soma total da população das cidades.
    """
    qnt_total = reduce(lambda acc, city: acc + int(city['population']), lista, 0)
    return qnt_total if total is None else False if total != qnt_total else True

"""
Examples
"""
res = city_data(results)
print(' city_data Aberta: ', res)
print(' city_data Fechada: ', city_data_closed(res, "Caacupé", 'http://dbpedia.org/resource/Paraguay', '56864', '145000000.0', '-25.38611030578613', '-57.14083480834961'))

print('\n city_with_max_population Aberta: ', city_with_max_population(res))
print(' city_with_max_population Fechada: ', city_with_max_population(res, '32054159', "Chongqing"))

print('\n city_with_min_population Aberta: ', city_with_min_population(res))
print(' city_with_min_population Fechada: ', city_with_min_population(res, '0', "Snihurivka"))

print('\n city_with_max_area Aberta: ', city_with_max_area(res))
print(' city_with_max_area Fechada: ', city_with_max_area(res, '635100000000.0', "Cornélio Procópio"))

print('\n city_with_min_area Aberta: ', city_with_min_area(res))
print(' city_with_min_area Fechada: ', city_with_min_area(res, '25899.88110336', "Clayton, Idaho"))

print('\n city_coordinates Aberta: ', city_coordinates(res))
print(' city_coordinates Fechada: ', city_coordinates(res, "Caacupé", '-25.38611030578613', '-57.14083480834961'))

print('\n cities_population_above_one_million Aberta: ', cities_population_above_one_million(res))
print(' cities_population_above_one_million Fechada: ', cities_population_above_one_million(res, 459))

print('\n city_density Aberta: ', city_density(res))
print(' city_density Fechada: ', city_density(res, 0.0003921655172413793, "Caacupé"))

print('\n countries_with_cities Aberta: ', countries_with_cities(res))
print(' countries_with_cities Fechada: ', countries_with_cities(res, ['http://dbpedia.org/resource/Paraguay']))

print('\n cities_with_substring Aberta: ', cities_with_substring(res))
print(' cities_with_substring Fechada: ', cities_with_substring(res, "Floria", "Florianópolis"))

print('\n cities_ordered_by_population_descending Aberta: ', cities_ordered_by_population_descending(res))
print(' cities_ordered_by_population_descending Fechada: ', cities_ordered_by_population_descending(res, ["Florianópolis"]))

print('\n total_cities_count Aberta: ', total_cities_count(res))
print(' total_cities_count Fechada: ', total_cities_count(res, 10000))

print('\n city_exists Aberta: ', city_exists(res))
print(' city_exists Fechada: ', city_exists(res, "Caacupé"))

print('\n total_population Aberta: ', total_population(res))
print(' total_population Fechada: ', total_population(res, 2343706860))