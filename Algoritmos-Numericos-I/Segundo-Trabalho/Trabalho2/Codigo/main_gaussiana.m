%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%              Segundo Trabalho de Algoritmos Numericos             %%%%%%%%%%%%% Autores: Gabriel Boasquives, Gabriel Falcone e Gabrielly Cariman  %%%%%%%%%%%%%                    Data: 03 de Setembro de 2021                   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%               1.3 Distribuiç˜ao Normal (Gaussiana)                 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -------------------------------- Tarefa 1 ---------------------------------- %FDP_Normal = @(x, mi, sigma) (1/sqrt(2*pi*sigma^2)) * exp(-(((x-mi).^2)/(2*sigma^2)));% -------------------------------- Tarefa 2 ---------------------------------- %x = -5:1:5; mi = 0; sigma = 1;fdp = normpdf(x, mi, sigma);my_fdp = FDP_Normal(x, mi, sigma);diferenca = fdp - my_fdp;fprintf(' Tarefa 2: \n');printTabX( diferenca, 'diferenca', '%0.2f', 'Difença entre a minha implementaç˜ao de FDP com a do sistema normpdf');% -------------------------------- Tarefa 3 ---------------------------------- %%%%%%%             G R A F I C O  P A R A M E T R I Z A D O              %%%%%%%figure(1);clf;hold on;grid on;leg = {};% Pares (mi, sigma)param = {  {0, sqrt(0.2)},  {0, sqrt(1.0)},  {0, sqrt(5.0)},  {-2.0, sqrt(0.5)},};x = -5:0.1:5;  % Intervalofor i=1:length(param)  mi = param{i}{1};  sigma = param{i}{2};  y = FDP_Normal(x, mi, sigma);  plot(x, y,"linewidth",2)%, 'iterpreter', 'tex');  leg{end+1} = sprintf('\\mu=%3.1f, \\sigma^2=%3.1f', mi, sigma^2);endylim([0 1.0]);xlabel('X');ylabel('FDP(X)');title('Normal Distribution Probability Density Functions (PDFs)');h = legend(leg);set (h, 'interpreter', 'tex', 'location', 'northeastoutside');hold off;% -------------------------------- Tarefa 4 ---------------------------------- %FDA_Normal = @(x, mi, sigma) (1+erf((x-mi)/(sigma*sqrt(2))))/2;x = -5:1:5; mi = 0; sigma = 1;fda = normcdf(x, mi, sigma);my_fda = FDA_Normal(x, mi, sigma);diferenca_fda = fda - my_fda;fprintf(' Tarefa 4: \n');printTabX( diferenca_fda, 'diferenca', '%0.2f', 'Difença entre a minha implementaç˜ao de FDA com a do sistema normcdf');figure(2);clf;hold on;grid on;leg1 = {};% Pares (mi, sigma)param = {  {0, sqrt(0.2)},  {0, sqrt(1.0)},  {0, sqrt(5.0)},  {-2.0, sqrt(0.5)},};x = -5:0.1:5;  % Intervalofor i=1:length(param)  mi = param{i}{1};  sigma = param{i}{2};  y = FDA_Normal(x, mi, sigma);  plot(x, y, "linewidth",2)%, 'iterpreter', 'tex');  leg1{end+1} = sprintf('\\mu=%3.1f, \\sigma^2=%3.1f', mi, sigma^2);endylim([0 1.0]);xlabel('X');ylabel('FDA(X)');title('Função de distribuição acumulada');h = legend(leg1);set (h, 'interpreter', 'tex', 'location', 'northeastoutside');hold off;% -------------------------------- Tarefa 5 ---------------------------------- %u = -2.0; sig2 = 0.5;FDA = 0.99;x = erfinv(2*FDA - 1)*sqrt(sig2)*sqrt(2) + u;fprintf(' Tarefa 5: \n');printf("O valor sera %d  \n\n",x);% -------------------------------- Tarefa 6 ---------------------------------- %mi = -2 ; sigma = sqrt(0.5);a = mi-10*sigma;FDP_Normal_intg = @(x) (1/sqrt(2*pi*sigma^2)) * exp(-(((x-mi).^2)/(2*sigma^2)));q_exato = integral(FDP_Normal_intg,a,x);fprintf(' Tarefa 6: \n');%Método dos trapéziosn_trapezio=0;err_trapezio = 1;while err_trapezio >= 0.01n_trapezio++;q_trapezio = integralTrapeziosRepetidaFunc(FDP_Normal_intg,a,x,n_trapezio,false);err_trapezio = abs(q_exato-q_trapezio);endwhileprintf("Para o método dos trapezios existirão %d subdivisões e o seu erro será de %d  \n",n_trapezio,err_trapezio);%Método 1/3 Simpsonn_simpson = 0;err_simpson = 1;while err_simpson>=0.01n_simpson = n_simpson+2;q_simpson = integralSimpsonRepetidaFunc( FDP_Normal_intg, a, x, n_simpson, false );err_simpson = abs(q_exato-q_simpson);endwhileprintf("\nPara o método de 1/3 de Simpson existirão %d subdivisões e o seu erro será de %d  \n\n",n_simpson,err_simpson);%Método Quadratura Gaussianan_quad = 0;err_quad = 1;while err_quad>=0.01n_quad++;C = coefGaussLegendre( n_quad+1 );[T, A] = tabelaAbcissasPesosGaussLegendre( C );q_quad = integralGaussLegendreFunc( FDP_Normal_intg, a, x, n_quad, T, A, false );err_quad = abs(q_exato-q_quad);endwhileprintf("\nPara o método de quadratura Gaussiana existirão %d subdivisões e o seu erro será de %d  \n\n\n",n_quad,err_quad);% -------------------------------- Tarefa 7 ---------------------------------- %mi = -2 ; sigma = sqrt(0.5);FDA_Normal_bisec = @(x) (1+erf((x-mi)/(sigma*sqrt(2))))/2 - 0.99;r = raizBisecPosFalsa( false, FDA_Normal_bisec, -1, 0, 1e-4, 10 );err_bisec = abs(x-r);fprintf('\n Tarefa 7: \n');printf("O valor do argumento para que a FDA tenha o valor de 0.99 será %d \n",r);% -------------------------------- Tarefa 8 ---------------------------------- %semente = 2021;randn('seed', semente);u8 = -2 ; sigma8 = 0.7;r = u8 + sigma8 * randn(1,1000);% -------------------------------- Tarefa 9 ---------------------------------- %u9 = mean(r); %calcula a média de acordo com a eq(8)sig9 = std(r); %calcula o desvio padrão com a eq(10)diff_u = abs(u8-u9);diff_sig = abs(sigma8-sig9);fprintf('\n Tarefa 9: \n');printf("Temos que sigma sera %d, mu sera %d. Diferença mu: %d. Diferença sigma: %d \n\n",sig9, u9,diff_u,diff_sig);